apiVersion: v1
kind: ConfigMap
metadata:
  name: ueransim-uav-config
  namespace: open5gs
data:
  ue.yaml.tpl: |
    supi: "imsi-999700000000001"
    mcc: "999"
    mnc: "70"

    key: "465B5CE8B199B49FAA5F0A2EE238A6BC"
    op:  "E8ED289DEBA952E4283B54E88E6183CA"
    opType: "OPC"
    amf: "8000"

    gnbSearchList:
      - "__GNB_IP__"

    uacAic:
      mps: false
      mcs: false

    uacAcc:
      normalClass: 0
      class11: false
      class12: false
      class13: false
      class14: false
      class15: false

    sessions:
      - type: "IPv4"
        apn: "internet"
        slice:
          sst: 1
          sd: "0x111111"

    configured-nssai:
      - sst: 1
        sd: "0x111111"

    default-nssai:
      - sst: 1
        sd: "0x111111"

    integrity:
      IA1: true
      IA2: true
      IA3: true

    ciphering:
      EA0: true
      EA1: true
      EA2: true
      EA3: true

    integrityMaxRate:
      uplink: "full"
      downlink: "full"
  uav: |
    #!/bin/bash

    # Obtém o IP do UAV pela interface tun (uesimtun0)
    IP_UAV=$(ip -o -4 addr show dev uesimtun0 | awk '{print $4}' | cut -d/ -f1)
    echo "[UAV] Meu IP (uesimtun0): $IP_UAV"

    # Solicita ao usuário o IP do GCS
    read -p "[UAV] Digite o IP do GCS (tun): " IP_GCS

    # Exibe para conferência
    echo "[UAV] IP do GCS informado: $IP_GCS"

    # Faz a substituição do placeholder no script Python
    sed -i "s|GCS_IP = '.*'|GCS_IP = '$IP_GCS'|g" /tmp/uav.py

    # Executa o script Python
    /opt/mavlink-venv/bin/python3 /tmp/uav.py
  uav.py: |
    import time
    import math
    import socket
    from pymavlink import mavutil

    GCS_IP = '<GCS_IP>'
    UAV_LISTEN_PORT = 14550
    GCS_LISTEN_PORT = 14551

    HB_PERIOD = 1.0
    POS_PERIOD = 0.5

    # Failsafe por perda de HEARTBEAT do GCS
    GCS_HB_TIMEOUT_S = 60.0      # 1 min sem HB do GCS -> RTL
    RETRY_LOG_PERIOD_S = 30.0    # loga tentativa/erro a cada 30s

    # RTL (simples e realista o suficiente)
    RTL_ALT_M = 30.0             # sobe até 30m (se abaixo) antes de voltar
    RTL_HOME_RADIUS_M = 0.2      # raio para considerar chegou em home

    home_lat = -23.2000000
    home_lon = -45.9000000
    lat = home_lat
    lon = home_lon
    rel_alt_m = 0.0

    armed = False
    flying = False
    mode = 'STANDBY'
    target_alt_m = 0.0

    north_m = 0.0
    east_m = 0.0
    target_north_m = 0.0
    target_east_m = 0.0
    move_active = False

    CLIMB_MPS = 2.0
    MOVE_MPS = 5.0

    # Link / failsafe (baseado SOMENTE em heartbeat do GCS)
    last_gcs_hb = time.time()
    link_up = True
    failsafe_active = False
    last_retry_log = 0.0

    # RTL state
    rtl_active = False
    rtl_phase = 'IDLE'  # IDLE | CLIMB | RETURN | LAND

    def log(s):
        print(s, flush=True)

    def send_statustext(tx, text, severity=mavutil.mavlink.MAV_SEVERITY_INFO):
        tx.mav.statustext_send(severity, text.encode('utf-8')[:50])

    def send_ack(tx, command, result):
        tx.mav.command_ack_send(command, result)

    def deg_per_meter_lat():
        return 1.0 / 111320.0

    def deg_per_meter_lon(lat_deg):
        return 1.0 / (111320.0 * max(0.2, math.cos(math.radians(lat_deg))))

    def start_rtl(tx):
        global failsafe_active, rtl_active, rtl_phase, mode
        global move_active, target_north_m, target_east_m, target_alt_m

        failsafe_active = True
        rtl_active = True
        mode = 'RTL'

        if not flying:
            # se estiver no chão, RTL vira basicamente "espera"
            rtl_phase = 'IDLE'
            send_statustext(tx, 'RTL: vehicle not flying (idle)', mavutil.mavlink.MAV_SEVERITY_WARNING)
            log('[UAV] RTL: veículo no chão (idle).')
            return

        # fase 1: subir até RTL_ALT (se necessário)
        if rel_alt_m < RTL_ALT_M:
            target_alt_m = RTL_ALT_M
            rtl_phase = 'CLIMB'
            send_statustext(tx, f'RTL: climbing to {RTL_ALT_M:.1f}m')
            log(f'[UAV] RTL: subindo até {RTL_ALT_M:.1f}m.')
        else:
            rtl_phase = 'RETURN'
            send_statustext(tx, 'RTL: returning to launch')
            log('[UAV] RTL: retornando para HOME.')

        # define home como alvo
        move_active = True
        target_north_m = 0.0
        target_east_m  = 0.0

    def tick_rtl(tx):
        global rtl_active, rtl_phase, mode, move_active
        global target_alt_m

        if not rtl_active or not flying:
            return

        if rtl_phase == 'CLIMB':
            # quando atingir altitude alvo, vai para RETURN
            if abs(rel_alt_m - target_alt_m) < 0.2:
                rtl_phase = 'RETURN'
                send_statustext(tx, 'RTL: returning to launch')
                log('[UAV] RTL: atingiu altitude, retornando para HOME.')

        elif rtl_phase == 'RETURN':
            # se chegou em home, inicia LAND
            dist_home = math.hypot(north_m - 0.0, east_m - 0.0)
            if dist_home <= RTL_HOME_RADIUS_M and (not move_active):
                rtl_phase = 'LAND'
                mode = 'LAND'
                send_statustext(tx, 'RTL: reached home, landing')
                log('[UAV] RTL: chegou em HOME, iniciando pouso.')

        elif rtl_phase == 'LAND':
            # LAND é tratado pelo bloco padrão de LAND
            pass

    def exit_failsafe_link_restored(tx):
        global link_up, failsafe_active
        link_up = True
        # realista: link voltar NÃO cancela RTL automaticamente
        failsafe_active = False
        send_statustext(tx, 'GCS HEARTBEAT RESTORED', mavutil.mavlink.MAV_SEVERITY_INFO)
        log('[UAV] link restaurado: heartbeat do GCS voltou.')

    rx = mavutil.mavlink_connection(f'udpin:0.0.0.0:{UAV_LISTEN_PORT}')
    tx = mavutil.mavlink_connection(f'udpout:{GCS_IP}:{GCS_LISTEN_PORT}')

    log(f'[UAV] ouvindo MAVLink em 0.0.0.0:{UAV_LISTEN_PORT} | enviando para {GCS_IP}:{GCS_LISTEN_PORT}')

    first = rx.recv_match(blocking=True, timeout=30)
    if first is None:
        log('[UAV] nenhuma mensagem recebida em 30s. Abortando.')
        raise SystemExit(1)

    log(f'[UAV] link ativo (primeira msg): {first.get_type()}')

    last_hb_tx = 0.0
    last_pos_tx = 0.0
    last_sim = time.time()

    try:
        while True:
            now = time.time()
            dt = now - last_sim
            last_sim = now

            # 1) DETECÇÃO DE LINK (somente heartbeat do GCS)
            if link_up and (now - last_gcs_hb) > GCS_HB_TIMEOUT_S:
                link_up = False
                log('[UAV] FAILSAFE: heartbeat do GCS perdido (>=60s). Entrando em RTL.')
                send_statustext(tx, 'GCS HEARTBEAT LOST - RTL', mavutil.mavlink.MAV_SEVERITY_CRITICAL)
                start_rtl(tx)
                last_retry_log = 0.0  # força log imediato

            if not link_up:
                if (now - last_retry_log) >= RETRY_LOG_PERIOD_S:
                    last_retry_log = now
                    log('[UAV] tentando reestabelecer link (aguardando heartbeat do GCS)...')
                    send_statustext(tx, 'Attempting link restore...', mavutil.mavlink.MAV_SEVERITY_WARNING)

            # 2) dinâmica de voo
            if flying:
                # altitude
                if abs(rel_alt_m - target_alt_m) < 0.05:
                    rel_alt_m = target_alt_m
                else:
                    step = CLIMB_MPS * dt
                    if rel_alt_m < target_alt_m:
                        rel_alt_m = min(target_alt_m, rel_alt_m + step)
                    else:
                        rel_alt_m = max(target_alt_m, rel_alt_m - step)

                # movimento
                if move_active:
                    dn = target_north_m - north_m
                    de = target_east_m - east_m
                    dist = math.hypot(dn, de)
                    if dist < 0.2:
                        north_m = target_north_m
                        east_m = target_east_m
                        move_active = False
                        send_statustext(tx, 'Reached target position')
                    else:
                        step = min(MOVE_MPS * dt, dist)
                        north_m += (dn / dist) * step
                        east_m  += (de / dist) * step

                lat = home_lat + north_m * deg_per_meter_lat()
                lon = home_lon + east_m  * deg_per_meter_lon(home_lat)

            # tick do RTL (transições CLIMB->RETURN->LAND)
            tick_rtl(tx)

            # LAND mode (padrão)
            if mode == 'LAND' and flying:
                target_alt_m = 0.0
                if rel_alt_m <= 0.05:
                    rel_alt_m = 0.0
                    flying = False
                    move_active = False
                    rtl_active = False
                    rtl_phase = 'IDLE'
                    mode = 'STANDBY'
                    send_statustext(tx, 'Landed')
                    log('[UAV] pousou.')

            # 3) TX: heartbeat do UAV + telemetria
            if now - last_hb_tx >= HB_PERIOD:
                tx.mav.heartbeat_send(
                    mavutil.mavlink.MAV_TYPE_QUADROTOR,
                    mavutil.mavlink.MAV_AUTOPILOT_ARDUPILOTMEGA,
                    0, 0, 0
                )
                last_hb_tx = now
                log('[UAV] heartbeat enviado')

            if now - last_pos_tx >= POS_PERIOD:
                lat_i = int(lat * 1e7)
                lon_i = int(lon * 1e7)
                rel_alt_mm = int(rel_alt_m * 1000)
                alt_mm = rel_alt_mm
                tx.mav.global_position_int_send(
                    int(now * 1000) & 0xFFFFFFFF,
                    lat_i, lon_i,
                    alt_mm, rel_alt_mm,
                    0, 0, 0,
                    0
                )
                last_pos_tx = now

            # 4) RX
            m = rx.recv_match(blocking=False)
            if m:
                t = m.get_type()
                d = m.to_dict()

                # Link: atualiza somente se for HEARTBEAT do GCS
                if t == 'HEARTBEAT':
                    src_sys = getattr(m, 'get_srcSystem', lambda: None)()
                    hb_type = int(d.get('type', -1))
                    if hb_type == mavutil.mavlink.MAV_TYPE_GCS or src_sys == 255:
                        last_gcs_hb = now
                        if not link_up:
                            exit_failsafe_link_restored(tx)

                if t in ('COMMAND_LONG', 'SET_MODE', 'SET_POSITION_TARGET_LOCAL_NED'):
                    log(f'[UAV] recebido: {t} | conteúdo: {d}')

                # durante perda real de link (link_up == False), ignora comandos (não tem GCS de fato)
                if not link_up:
                    time.sleep(0.02)
                    continue

                # comandos normais (quando link está OK)
                if t == 'SET_MODE':
                    cm = int(d.get('custom_mode', 0))
                    if cm == 4:
                        mode = 'GUIDED'
                        rtl_active = False
                        rtl_phase = 'IDLE'
                    elif cm == 5:
                        mode = 'LOITER'
                    elif cm == 9:
                        mode = 'LAND'
                    else:
                        mode = 'STANDBY'
                    send_statustext(tx, 'Mode change requested')

                elif t == 'COMMAND_LONG':
                    cmd = int(d.get('command', -1))
                    p1 = float(d.get('param1', 0.0))
                    p7 = float(d.get('param7', 0.0))

                    # ARM/DISARM
                    if cmd == mavutil.mavlink.MAV_CMD_COMPONENT_ARM_DISARM:
                        if p1 >= 1.0:
                            if armed:
                                send_ack(tx, cmd, mavutil.mavlink.MAV_RESULT_ACCEPTED)
                                send_statustext(tx, 'Already armed')
                            else:
                                armed = True
                                send_ack(tx, cmd, mavutil.mavlink.MAV_RESULT_ACCEPTED)
                                send_statustext(tx, 'Motors armed')
                        else:
                            if flying and rel_alt_m > 0.5:
                                send_ack(tx, cmd, mavutil.mavlink.MAV_RESULT_DENIED)
                                send_statustext(tx, 'Disarm denied: airborne', mavutil.mavlink.MAV_SEVERITY_WARNING)
                            else:
                                armed = False
                                send_ack(tx, cmd, mavutil.mavlink.MAV_RESULT_ACCEPTED)
                                send_statustext(tx, 'Motors disarmed')

                    # TAKEOFF
                    elif cmd == mavutil.mavlink.MAV_CMD_NAV_TAKEOFF:
                        desired = float(p7)

                        if not armed:
                            send_ack(tx, cmd, mavutil.mavlink.MAV_RESULT_DENIED)
                            send_statustext(tx, 'Takeoff denied: not armed', mavutil.mavlink.MAV_SEVERITY_WARNING)
                        elif mode != 'GUIDED':
                            send_ack(tx, cmd, mavutil.mavlink.MAV_RESULT_DENIED)
                            send_statustext(tx, 'Takeoff denied: not GUIDED', mavutil.mavlink.MAV_SEVERITY_WARNING)
                        elif flying:
                            send_ack(tx, cmd, mavutil.mavlink.MAV_RESULT_DENIED)
                            send_statustext(tx, 'Takeoff denied: already flying', mavutil.mavlink.MAV_SEVERITY_WARNING)
                        elif desired <= 0.5:
                            send_ack(tx, cmd, mavutil.mavlink.MAV_RESULT_DENIED)
                            send_statustext(tx, 'Takeoff denied: altitude too low', mavutil.mavlink.MAV_SEVERITY_WARNING)
                        else:
                            flying = True
                            target_alt_m = desired
                            send_ack(tx, cmd, mavutil.mavlink.MAV_RESULT_ACCEPTED)
                            send_statustext(tx, f'Taking off to {desired:.1f}m')

                    # LAND
                    elif cmd == mavutil.mavlink.MAV_CMD_NAV_LAND:
                        if not flying:
                            send_ack(tx, cmd, mavutil.mavlink.MAV_RESULT_DENIED)
                            send_statustext(tx, 'Land denied: not flying', mavutil.mavlink.MAV_SEVERITY_WARNING)
                        else:
                            mode = 'LAND'
                            send_ack(tx, cmd, mavutil.mavlink.MAV_RESULT_ACCEPTED)
                            send_statustext(tx, 'Landing...')

                    else:
                        send_ack(tx, cmd, mavutil.mavlink.MAV_RESULT_UNSUPPORTED)

                elif t == 'SET_POSITION_TARGET_LOCAL_NED':
                    if not flying:
                        send_statustext(tx, 'Move denied: not flying', mavutil.mavlink.MAV_SEVERITY_WARNING)
                    elif mode != 'GUIDED':
                        send_statustext(tx, 'Move denied: not GUIDED', mavutil.mavlink.MAV_SEVERITY_WARNING)
                    else:
                        x = float(d.get('x', 0.0))
                        y = float(d.get('y', 0.0))
                        z = float(d.get('z', 0.0))
                        target_north_m = x
                        target_east_m = y
                        move_active = True
                        desired_alt = max(0.0, -z)
                        if desired_alt > 0.0:
                            target_alt_m = desired_alt
                        send_statustext(tx, f'Moving to N={x:.1f} E={y:.1f} alt~{target_alt_m:.1f}m')

            time.sleep(0.02)

    except KeyboardInterrupt:
        log('\\n[UAV] encerrado.')
